
#include "main.h"
#include "ff.h"
#include "diskio.h"
#include "w25qxx.h"
#include "ESP_PSRAM64.h"
#include "jansson.h"


QSPI_HandleTypeDef hqspi        = {0};
SPI_HandleTypeDef hspi2         = {0};
QSPI_Info QSPI_info 	        = {0};


FATFS FlashFatFs, PSRamFatFs;   /* File system object for each logical drive */
FIL   FlashFile, PSRamFile;     /* File objects */
DIR   FlashDir, PSRamDir;       /* Directory object */
BYTE FF_WorkBuff[FF_MAX_SS] __attribute__ ((aligned (4))) ;	/* Working buffer */


#define EnablePrivilegedMode() __asm("SVC #0")

bool FLASH_EXECUTE____FLAG = false;
typedef  void (*pFunction)(void);
pFunction JumpToApplication;

uint8_t Data_Flash_RBuff[4096] = {0U}, Data_Flash_WBuff[4096] = {0U};

const uint8_t SingleLineExample[3331] = {
    0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x7B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x22, 0x74, 0x69, 0x74, 
    0x6C, 0x65, 0x22, 0x3A, 0x20, 0x22, 0x50, 0x61, 0x67, 0x65, 0x5F, 0x31, 0x22, 0x2C, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x22, 0x73, 0x69, 0x67, 0x6E, 0x61, 0x6C, 0x73, 0x22, 0x3A, 0x20, 0x5B, 
    0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x22, 0x5F, 0x6C, 0x6F, 0x63, 0x22, 0x3A, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 
    0x5F, 0x6D, 0x68, 0x61, 0x61, 0x64, 0x72, 0x22, 0x3A, 0x20, 0x34, 0x38, 0x38, 0x2C, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x5F, 0x6C, 0x62, 0x6C, 0x22, 0x3A, 0x20, 
    0x22, 0x6A, 0x61, 0x74, 0x20, 0x69, 0x6E, 0x6A, 0x61, 0x73, 0x74, 0x22, 0x2C, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x5F, 0x74, 0x79, 0x70, 0x65, 0x22, 0x3A, 0x20, 
    0x32, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x5F, 0x6E, 0x6F, 
    0x64, 0x70, 0x22, 0x3A, 0x20, 0x32, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x22, 0x5F, 0x64, 0x77, 0x75, 0x22, 0x3A, 0x20, 0x74, 0x72, 0x75, 0x65, 0x2C, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x5F, 0x64, 0x77, 0x61, 0x22, 0x3A, 0x20, 
    0x66, 0x61, 0x6C, 0x73, 0x65, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x22, 0x5F, 0x73, 0x69, 0x67, 0x70, 0x22, 0x3A, 0x20, 0x22, 0x74, 0x65, 0x73, 0x74, 0x2F, 0x74, 
    0x65, 0x73, 0x74, 0x2F, 0x74, 0x65, 0x73, 0x74, 0x2F, 0x74, 0x65, 0x73, 0x74, 0x22, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x5F, 0x63, 0x6F, 0x6E, 0x64, 0x65, 
    0x76, 0x22, 0x3A, 0x20, 0x22, 0x74, 0x65, 0x73, 0x74, 0x22, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x7D, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x22, 0x73, 0x79, 0x6D, 0x62, 0x6F, 0x6C, 0x73, 0x22, 0x3A, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x7B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x22, 0x5F, 0x6C, 0x6F, 0x63, 0x22, 0x3A, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x34, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x38, 0x38, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x5F, 0x73, 0x65, 
    0x71, 0x22, 0x3A, 0x20, 0x31, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x22, 0x6E, 0x61, 0x6D, 0x65, 0x22, 0x3A, 0x20, 0x22, 0x41, 0x52, 0x31, 0x22, 0x2C, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x5F, 0x6C, 0x62, 0x6C, 0x22, 0x3A, 0x20, 
    0x22, 0x41, 0x52, 0x31, 0x22, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x22, 0x5F, 0x63, 0x6F, 0x6E, 0x64, 0x65, 0x76, 0x22, 0x3A, 0x20, 0x22, 0x74, 0x65, 0x73, 0x74, 
    0x22, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x5F, 0x70, 0x6F, 
    0x69, 0x6E, 0x74, 0x22, 0x3A, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x34, 0x34, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x38, 0x38, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x2D, 0x32, 0x31, 0x34, 0x37, 0x34, 0x38, 0x33, 0x36, 0x30, 0x34, 0x2C, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x2D, 0x32, 0x31, 0x34, 0x37, 0x34, 0x38, 
    0x33, 0x35, 0x36, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 
    0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x5F, 0x73, 0x68, 0x61, 0x70, 
    0x65, 0x73, 0x22, 0x3A, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x7B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x22, 0x6E, 0x61, 0x6D, 0x65, 0x22, 0x3A, 0x20, 0x22, 0x4E, 0x65, 0x77, 0x20, 0x65, 0x6C, 
    0x65, 0x6D, 0x65, 0x6E, 0x74, 0x22, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x6C, 0x61, 0x62, 0x65, 0x6C, 0x22, 0x3A, 0x20, 0x22, 0x4E, 
    0x65, 0x77, 0x20, 0x65, 0x6C, 0x65, 0x6D, 0x65, 0x6E, 0x74, 0x22, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x77, 0x69, 0x64, 0x74, 0x68, 
    0x22, 0x3A, 0x20, 0x38, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x22, 0x68, 0x65, 0x69, 0x67, 0x68, 0x74, 0x22, 0x3A, 0x20, 0x38, 0x30, 
    0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 
    0x70, 0x6F, 0x72, 0x74, 0x73, 0x22, 0x3A, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x35, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x32, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x35, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 
    0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x35, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x36, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x36, 0x35, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x31, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x37, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x35, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 
    0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x37, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x32, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x37, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x32, 0x35, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x37, 0x35, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x33, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x37, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x33, 0x35, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 
    0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x36, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x36, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x35, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x30, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x32, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x33, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x35, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 
    0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x33, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x32, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x32, 0x30, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x31, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x35, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 
    0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x32, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x31, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x32, 0x35, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x30, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x33, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x31, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x33, 0x35, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 
    0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x32, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x32, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x35, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x33, 0x30, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x35, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x30, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 
    0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x35, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x35, 0x35, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x34, 0x35, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x36, 0x30, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x33, 0x35, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x35, 0x35, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x5B, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x34, 0x30, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x36, 0x30, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 
    0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 
    0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x6C, 
    0x69, 0x6E, 0x65, 0x73, 0x22, 0x3A, 0x20, 0x5B, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x72, 0x65, 0x63, 0x74, 0x61, 0x6E, 0x67, 
    0x6C, 0x65, 0x73, 0x22, 0x3A, 0x20, 0x5B, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x65, 0x6C, 0x6C, 0x69, 0x70, 0x73, 0x65, 0x73, 
    0x22, 0x3A, 0x20, 0x5B, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x22, 0x61, 0x72, 0x63, 0x73, 0x22, 0x3A, 0x20, 0x5B, 0x5D, 0x2C, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x22, 0x70, 0x6F, 
    0x6C, 0x79, 0x4F, 0x75, 0x74, 0x4C, 0x69, 0x6E, 0x65, 0x73, 0x22, 0x3A, 0x20, 0x5B, 0x5D, 0x0D, 
    0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7D, 0x0D, 0x0A, 0x20, 0x20, 
    0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7D, 
    0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x5D, 0x2C, 0x0D, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x22, 0x6C, 
    0x69, 0x6E, 0x65, 0x73, 0x22, 0x3A, 0x20, 0x6E, 0x75, 0x6C, 0x6C, 0x0D, 0x0A, 0x20, 0x20, 0x7D, 
    0x0D, 0x0A, 0x5D, 
} ;

json_t *SingleLingeElements;

void SystemClock_Config(void);
static void MPU_RegionConfig(void);
static void MX_GPIO_Init(void);
static void MX_QUADSPI_Init(void);
static void MX_SPI2_Init(void);






void print_json(json_t *root);
void print_json_aux(json_t *element, int indent);
void print_json_indent(int indent);
const char *json_plural(size_t count);
void print_json_object(json_t *element, int indent);
void print_json_array(json_t *element, int indent);
void print_json_string(json_t *element, int indent);
void print_json_integer(json_t *element, int indent);
void print_json_real(json_t *element, int indent);
void print_json_true(json_t *element, int indent);
void print_json_false(json_t *element, int indent);
void print_json_null(json_t *element, int indent);

void print_json(json_t *root) { print_json_aux(root, 0); }

void print_json_aux(json_t *element, int indent) {
    switch (json_typeof(element)) {
        case JSON_OBJECT:
            print_json_object(element, indent);
            break;
        case JSON_ARRAY:
            print_json_array(element, indent);
            break;
        case JSON_STRING:
            print_json_string(element, indent);
            break;
        case JSON_INTEGER:
            print_json_integer(element, indent);
            break;
        case JSON_REAL:
            print_json_real(element, indent);
            break;
        case JSON_TRUE:
            print_json_true(element, indent);
            break;
        case JSON_FALSE:
            print_json_false(element, indent);
            break;
        case JSON_NULL:
            print_json_null(element, indent);
            break;
        default:
            fprintf(stderr, "unrecognized JSON type %d\n", json_typeof(element));
    }
}

void print_json_indent(int indent) {
    int i;
    for (i = 0; i < indent; i++) {
        putchar(' ');
    }
}

const char *json_plural(size_t count) { return count == 1 ? "" : "s"; }

void print_json_object(json_t *element, int indent) {
    size_t size;
    const char *key;
    json_t *value;

    print_json_indent(indent);
    size = json_object_size(element);

    printf("JSON Object of %lld pair%s:\n", (long long)size, json_plural(size));
    json_object_foreach(element, key, value) {
        print_json_indent(indent + 2);
        printf("JSON Key: \"%s\"\n", key);
        print_json_aux(value, indent + 2);
    }
}

void print_json_array(json_t *element, int indent) {
    size_t i;
    size_t size = json_array_size(element);
    print_json_indent(indent);

    printf("JSON Array of %lld element%s:\n", (long long)size, json_plural(size));
    for (i = 0; i < size; i++) {
        print_json_aux(json_array_get(element, i), indent + 2);
    }
}

void print_json_string(json_t *element, int indent) {
    print_json_indent(indent);
    printf("JSON String: \"%s\"\n", json_string_value(element));
}

void print_json_integer(json_t *element, int indent) {
    print_json_indent(indent);
    printf("JSON Integer: \"%" JSON_INTEGER_FORMAT "\"\n", json_integer_value(element));
}

void print_json_real(json_t *element, int indent) {
    print_json_indent(indent);
    printf("JSON Real: %f\n", json_real_value(element));
}

void print_json_true(json_t *element, int indent) {
    (void)element;
    print_json_indent(indent);
    printf("JSON True\n");
}

void print_json_false(json_t *element, int indent) {
    (void)element;
    print_json_indent(indent);
    printf("JSON False\n");
}

void print_json_null(json_t *element, int indent) {
    (void)element;
    print_json_indent(indent);
    printf("JSON Null\n");
}

/*
 * Parse text into a JSON object. If text is valid JSON, returns a
 * json_t structure, otherwise prints and error and returns null.
 */
json_t *load_json(const char *text) {
    json_t *root;
    json_error_t error;

    root = json_loads(text, 0, &error);

    if (root) {
        return root;
    } else {
        fprintf(stderr, "json error on line %d: %s\n", error.line, error.text);
        return (json_t *)0;
    }
}

/*
 * Print a prompt and return (by reference) a null-terminated line of
 * text.  Returns NULL on eof or some error.
 */
char *read_line(char *line, int max_chars) {
    printf("Type some JSON > ");
    fflush(stdout);
    return fgets(line, max_chars, stdin);
}







static void test_misc(void) {
  json_t *array, *five, *seven, *value;
  size_t i;
  
  array = json_array();
  five = json_integer(5);
  seven = json_integer(7);
  
  if (!array)
    printf("unable to create array");
  if (!five || !seven)
    printf("unable to create integer");
  
  if (json_array_size(array) != 0)
    printf("empty array has nonzero size");
  
  if (!json_array_append(array, NULL))
    printf("able to append NULL");
  
  if (json_array_append(array, five))
    printf("unable to append");
  
  if (json_array_size(array) != 1)
    printf("wrong array size");
  
  value = json_array_get(array, 0);
  if (!value)
    printf("unable to get item");
  if (value != five)
    printf("got wrong value");
  
  if (json_array_append(array, seven))
    printf("unable to append value");
  
  if (json_array_size(array) != 2)
    printf("wrong array size");
  
  value = json_array_get(array, 1);
  if (!value)
    printf("unable to get item");
  if (value != seven)
    printf("got wrong value");
  
  if (json_array_set(array, 0, seven))
    printf("unable to set value");
  
  if (!json_array_set(array, 0, NULL))
    printf("able to set NULL");
  
  if (json_array_size(array) != 2)
    printf("wrong array size");
  
  value = json_array_get(array, 0);
  if (!value)
    printf("unable to get item");
  if (value != seven)
    printf("got wrong value");
  
  if (json_array_get(array, 2) != NULL)
    printf("unable to get value out of bounds");
  
  if (!json_array_set(array, 2, seven))
    printf("unable to set value out of bounds");
  
  for (i = 2; i < 30; i++) {
    if (json_array_append(array, seven))
      printf("unable to append value");
    
    if (json_array_size(array) != i + 1)
      printf("wrong array size");
  }
  
  for (i = 0; i < 30; i++) {
    value = json_array_get(array, i);
    if (!value)
      printf("unable to get item");
    if (value != seven)
      printf("got wrong value");
  }
  
  if (json_array_set_new(array, 15, json_integer(123)))
    printf("unable to set new value");
  
  value = json_array_get(array, 15);
  if (!json_is_integer(value) || json_integer_value(value) != 123)
    printf("json_array_set_new works incorrectly");
  
  if (!json_array_set_new(array, 15, NULL))
    printf("able to set_new NULL value");
  
  if (json_array_append_new(array, json_integer(321)))
    printf("unable to append new value");
  
  value = json_array_get(array, json_array_size(array) - 1);
  if (!json_is_integer(value) || json_integer_value(value) != 321)
    printf("json_array_append_new works incorrectly");
  
  if (!json_array_append_new(array, NULL))
    printf("able to append_new NULL value");
  
  print_json(array);
  
  json_decref(five);
  json_decref(seven);
  json_decref(array);
}

static void test_insert(void) {
  json_t *array, *five, *seven, *eleven, *value;
  int i;
  
  array = json_array();
  five = json_integer(5);
  seven = json_integer(7);
  eleven = json_integer(11);
  
  if (!array)
    printf("unable to create array");
  if (!five || !seven || !eleven)
    printf("unable to create integer");
  
  if (!json_array_insert(array, 1, five))
    printf("able to insert value out of bounds");
  
  if (json_array_insert(array, 0, five))
    printf("unable to insert value in an empty array");
  
  if (json_array_get(array, 0) != five)
    printf("json_array_insert works incorrectly");
  
  if (json_array_size(array) != 1)
    printf("array size is invalid after insertion");
  
  if (json_array_insert(array, 1, seven))
    printf("unable to insert value at the end of an array");
  
  if (json_array_get(array, 0) != five)
    printf("json_array_insert works incorrectly");
  
  if (json_array_get(array, 1) != seven)
    printf("json_array_insert works incorrectly");
  
  if (json_array_size(array) != 2)
    printf("array size is invalid after insertion");
  
  if (json_array_insert(array, 1, eleven))
    printf("unable to insert value in the middle of an array");
  
  if (json_array_get(array, 0) != five)
    printf("json_array_insert works incorrectly");
  
  if (json_array_get(array, 1) != eleven)
    printf("json_array_insert works incorrectly");
  
  if (json_array_get(array, 2) != seven)
    printf("json_array_insert works incorrectly");
  
  if (json_array_size(array) != 3)
    printf("array size is invalid after insertion");
  
  if (json_array_insert_new(array, 2, json_integer(123)))
    printf("unable to insert value in the middle of an array");
  
  value = json_array_get(array, 2);
  if (!json_is_integer(value) || json_integer_value(value) != 123)
    printf("json_array_insert_new works incorrectly");
  
  if (json_array_size(array) != 4)
    printf("array size is invalid after insertion");
  
  for (i = 0; i < 20; i++) {
    if (json_array_insert(array, 0, seven))
      printf("unable to insert value at the beginning of an array");
  }
  
  for (i = 0; i < 20; i++) {
    if (json_array_get(array, i) != seven)
      printf("json_aray_insert works incorrectly");
  }
  
  if (json_array_size(array) != 24)
    printf("array size is invalid after loop insertion");
  
  print_json(array);
  
  json_decref(five);
  json_decref(seven);
  json_decref(eleven);
  json_decref(array);
}

static void test_remove(void) {
  json_t *array, *five, *seven;
  int i;
  
  array = json_array();
  five = json_integer(5);
  seven = json_integer(7);
  
  if (!array)
    printf("unable to create array");
  if (!five)
    printf("unable to create integer");
  if (!seven)
    printf("unable to create integer");
  
  if (!json_array_remove(array, 0))
    printf("able to remove an unexisting index");
  
  if (json_array_append(array, five))
    printf("unable to append");
  
  if (!json_array_remove(array, 1))
    printf("able to remove an unexisting index");
  
  if (json_array_remove(array, 0))
    printf("unable to remove");
  
  if (json_array_size(array) != 0)
    printf("array size is invalid after removing");
  
  if (json_array_append(array, five) || json_array_append(array, seven) ||
      json_array_append(array, five) || json_array_append(array, seven))
    printf("unable to append");
  
  if (json_array_remove(array, 2))
    printf("unable to remove");
  
  if (json_array_size(array) != 3)
    printf("array size is invalid after removing");
  
  if (json_array_get(array, 0) != five || json_array_get(array, 1) != seven ||
      json_array_get(array, 2) != seven)
    printf("remove works incorrectly");
  
  json_decref(array);
  
  array = json_array();
  for (i = 0; i < 4; i++) {
    json_array_append(array, five);
    json_array_append(array, seven);
  }
  if (json_array_size(array) != 8)
    printf("unable to append 8 items to array");
  
  /* Remove an element from a "full" array. */
  json_array_remove(array, 5);
  
  
  json_decref(five);
  json_decref(seven);
  json_decref(array);
}

static void test_clear(void) {
  json_t *array, *five, *seven;
  int i;
  
  array = json_array();
  five = json_integer(5);
  seven = json_integer(7);
  
  if (!array)
    printf("unable to create array");
  if (!five || !seven)
    printf("unable to create integer");
  
  for (i = 0; i < 10; i++) {
    if (json_array_append(array, five))
      printf("unable to append");
  }
  for (i = 0; i < 10; i++) {
    if (json_array_append(array, seven))
      printf("unable to append");
  }
  
  if (json_array_size(array) != 20)
    printf("array size is invalid after appending");
  
  if (json_array_clear(array))
    printf("unable to clear");
  
  if (json_array_size(array) != 0)
    printf("array size is invalid after clearing");
  
  json_decref(five);
  json_decref(seven);
  json_decref(array);
}

static void test_extend(void) {
  json_t *array1, *array2, *five, *seven;
  int i;
  
  array1 = json_array();
  array2 = json_array();
  five = json_integer(5);
  seven = json_integer(7);
  
  if (!array1 || !array2)
    printf("unable to create array");
  if (!five || !seven)
    printf("unable to create integer");
  
  for (i = 0; i < 10; i++) {
    if (json_array_append(array1, five))
      printf("unable to append");
  }
  for (i = 0; i < 10; i++) {
    if (json_array_append(array2, seven))
      printf("unable to append");
  }
  
  if (json_array_size(array1) != 10 || json_array_size(array2) != 10)
    printf("array size is invalid after appending");
  
  if (json_array_extend(array1, array2))
    printf("unable to extend");
  
  for (i = 0; i < 10; i++) {
    if (json_array_get(array1, i) != five)
      printf("invalid array contents after extending");
  }
  for (i = 10; i < 20; i++) {
    if (json_array_get(array1, i) != seven)
      printf("invalid array contents after extending");
  }
  
  json_decref(five);
  json_decref(seven);
  json_decref(array1);
  json_decref(array2);
}

static void test_circular() {
  json_t *array1, *array2;
  
  /* the simple cases are checked */
  
  array1 = json_array();
  if (!array1)
    printf("unable to create array");
  
  if (json_array_append(array1, array1) == 0)
    printf("able to append self");
  
  if (json_array_insert(array1, 0, array1) == 0)
    printf("able to insert self");
  
  if (json_array_append_new(array1, json_true()))
    printf("failed to append true");
  
  if (json_array_set(array1, 0, array1) == 0)
    printf("able to set self");
  
  json_decref(array1);
  
  /* create circular references */
  
  array1 = json_array();
  array2 = json_array();
  if (!array1 || !array2)
    printf("unable to create array");
  
  if (json_array_append(array1, array2) || json_array_append(array2, array1))
    printf("unable to append");
  
  /* circularity is detected when dumping */
  if (json_dumps(array1, 0) != NULL)
    printf("unable to dump circulars");
  
  /* decref twice to deal with the circular references */
  json_decref(array1);
  json_decref(array2);
  json_decref(array1);
}

static void test_array_foreach() {
  size_t index;
  json_t *array1, *array2, *value;
  
  array1 = json_pack("[sisisi]", "foo", 1, "bar", 2, "baz", 3);
  array2 = json_array();
  
  json_array_foreach(array1, index, value) { json_array_append(array2, value); }
  
  if (!json_equal(array1, array2))
    printf("json_array_foreach failed to iterate all elements");
  
  json_decref(array1);
  json_decref(array2);
}

static void test_bad_args(void) {
  json_t *arr = json_array();
  json_t *num = json_integer(1);
  
  if (!arr || !num)
    printf("failed to create required objects");
  
  if (json_array_size(NULL) != 0)
    printf("NULL array has nonzero size");
  if (json_array_size(num) != 0)
    printf("non-array has nonzero array size");
  
  if (json_array_get(NULL, 0))
    printf("json_array_get did not return NULL for non-array");
  if (json_array_get(num, 0))
    printf("json_array_get did not return NULL for non-array");
  
  if (!json_array_set_new(NULL, 0, json_incref(num)))
    printf("json_array_set_new did not return error for non-array");
  if (!json_array_set_new(num, 0, json_incref(num)))
    printf("json_array_set_new did not return error for non-array");
  if (!json_array_set_new(arr, 0, NULL))
    printf("json_array_set_new did not return error for NULL value");
  if (!json_array_set_new(arr, 0, json_incref(arr)))
    printf("json_array_set_new did not return error for value == array");
  
  if (!json_array_remove(NULL, 0))
    printf("json_array_remove did not return error for non-array");
  if (!json_array_remove(num, 0))
    printf("json_array_remove did not return error for non-array");
  
  if (!json_array_clear(NULL))
    printf("json_array_clear did not return error for non-array");
  if (!json_array_clear(num))
    printf("json_array_clear did not return error for non-array");
  
  if (!json_array_append_new(NULL, json_incref(num)))
    printf("json_array_append_new did not return error for non-array");
  if (!json_array_append_new(num, json_incref(num)))
    printf("json_array_append_new did not return error for non-array");
  if (!json_array_append_new(arr, NULL))
    printf("json_array_append_new did not return error for NULL value");
  if (!json_array_append_new(arr, json_incref(arr)))
    printf("json_array_append_new did not return error for value == array");
  
  if (!json_array_insert_new(NULL, 0, json_incref(num)))
    printf("json_array_insert_new did not return error for non-array");
  if (!json_array_insert_new(num, 0, json_incref(num)))
    printf("json_array_insert_new did not return error for non-array");
  if (!json_array_insert_new(arr, 0, NULL))
    printf("json_array_insert_new did not return error for NULL value");
  if (!json_array_insert_new(arr, 0, json_incref(arr)))
    printf("json_array_insert_new did not return error for value == array");
  
  if (!json_array_extend(NULL, arr))
    printf("json_array_extend did not return error for first argument "
           "non-array");
  if (!json_array_extend(num, arr))
    printf("json_array_extend did not return error for first argument "
           "non-array");
  if (!json_array_extend(arr, NULL))
    printf("json_array_extend did not return error for second argument "
           "non-array");
  if (!json_array_extend(arr, num))
    printf("json_array_extend did not return error for second argument "
           "non-array");
  
  if (num->refcount != 1)
    printf("unexpected reference count on num");
  if (arr->refcount != 1)
    printf("unexpected reference count on arr");
  
  json_decref(num);
  json_decref(arr);
}

static void run_tests() {
  test_misc();
  test_insert();
  test_remove();
  test_clear();
  test_extend();
  test_circular();
  test_array_foreach();
  test_bad_args();
}









FILINFO Finfo;
static FRESULT scan_files (
                           char* path,		/* Pointer to the path name working buffer */
                           UINT* n_dir,
                           UINT* n_file,
                           QWORD* sz_file
                             )
{
  DIR dirs;
  FRESULT res;
  BYTE i;
  
  
  if ((res = f_opendir(&dirs, path)) == FR_OK) {
    i = strlen(path);
    while (((res = f_readdir(&dirs, &Finfo)) == FR_OK) && Finfo.fname[0]) {
      if (Finfo.fattrib & AM_DIR) {
        (*n_dir)++;
        *(path+i) = '/'; strcpy(path+i+1, Finfo.fname);
        res = scan_files(path, n_dir, n_file, sz_file);
        *(path+i) = '\0';
        if (res != FR_OK) break;
      } else {
        /*	xprintf("%s/%s\n", path, fn); */
        (*n_file)++;
        *sz_file += Finfo.fsize;
      }
    }
  }
  
  return res;
}






int main(void){
  QSPI_CommandTypeDef s_command = {0};
  QSPI_MemoryMappedTypeDef sMemMappedCfg = {0};
  
  MPU_RegionConfig();
  
  
  SCB_EnableICache();
  SCB_EnableDCache();
  
  HAL_Init();
  
  SystemClock_Config();
  
  MX_GPIO_Init();
  MX_QUADSPI_Init();
  MX_SPI2_Init();
  
  if(BSP_QSPI_Init() != QSPI_OK)  {
    Error_Handler();
  }
  
  BSP_QSPI_GetInfo(&QSPI_info);
   

 
  
  
  
  
  
  
//  run_tests();
//  
//  while(1);
//
//  
//
//  uint32_t TimeCheck = HAL_GetTick();
//  json_error_t error;				
//  SingleLingeElements = json_loads((const char*)SingleLineExample, 0, &error); 
//  printf("json_loads: %d ms\r\n", HAL_GetTick() - TimeCheck);
//
//  if(json_is_array(SingleLingeElements)){
//    printf("SingleLingeElements format correct\r\n");
//  }
//  else{
//      printf("SingleLingeElements format error:%d-%s\r\n", error.line, error.text);
//  }
//  
//  
//    
//  bool SingleLineDebug = true;
//  json_t *SymbolObj[10];
//  
//  for(uint32_t page_cnt=0; page_cnt<json_array_size(SingleLingeElements); page_cnt++){
//    SymbolObj[0] = json_array_get(SingleLingeElements, page_cnt);
//    if(json_is_object(SymbolObj[0])){
//      //-------- S: title object --------
//      if(SingleLineDebug==true) printf("page[%d].title : %s\r\n", page_cnt, json_string_value(json_object_get(SymbolObj[0], "title")));
//      //-------- E: title object --------
//      
//      //-------- S: signals object --------
//      SymbolObj[1] = json_object_get(SymbolObj[0], "signals");
//      if(json_is_array(SymbolObj[1])){
//        for(uint32_t signals_cnt=0; signals_cnt<json_array_size(SymbolObj[1]); signals_cnt++){
//          SymbolObj[2] = json_array_get(SymbolObj[1], signals_cnt);
//          if(json_is_object(SymbolObj[2])){
//            //-------- S: location --------
//            SymbolObj[3] = json_object_get(SymbolObj[2], "_loc");
//            if(json_is_array(SymbolObj[3])){
//              if(SingleLineDebug==true) printf("page[%d].signals[%d].location: (%d,%d)\r\n", page_cnt, signals_cnt, (int32_t)json_integer_value(json_array_get(SymbolObj[3], 0)), (int32_t)json_integer_value(json_array_get(SymbolObj[3], 1)));
//            }
//            //-------- E: location --------
//            
//            //-------- S: mhaaddress --------
//            if(SingleLineDebug==true) printf("page[%d].signals[%d].mhaaddress: %d\r\n", page_cnt, signals_cnt, (int32_t)json_integer_value(json_object_get(SymbolObj[2], "_mhaadr")));
//            //-------- E: mhaaddress --------
//          }
//        }
//      }
//    }
//  }
//  
//
//  
//  while(1);
  
  
  
  
  
  
#if(0)
  PSRAM_Init();
  
  
 
  uint8_t PSRAM_ReadBuff[1024], PSRAM_WriteBuff[1024];
    
  memset(PSRAM_ReadBuff, 0, sizeof(PSRAM_ReadBuff));
  memset(PSRAM_WriteBuff, 0x32, sizeof(PSRAM_WriteBuff));
  
  for(uint32_t i=0; i<8*1024*1024; i+=1024){
    PSRAM_Write_bytes(i, &PSRAM_WriteBuff[0], sizeof(PSRAM_WriteBuff));
    PSRAM_Read_bytes (i, &PSRAM_ReadBuff[0],  sizeof(PSRAM_ReadBuff));
    
    if(memcmp(PSRAM_WriteBuff, PSRAM_ReadBuff, sizeof(PSRAM_WriteBuff)) != 0){
      printf("PSRAM Mismatch data found, count: %d\n", i);
      while(1);
    }
    
    memset(PSRAM_ReadBuff, 0, sizeof(PSRAM_ReadBuff));
  }
#endif  
  
  
  
  
  
  
  
  FRESULT fr; 
  
  fr = f_mount(&FlashFatFs, "/flash", 0);
  if(fr == FR_OK){
    printf("Flash mount ok!\r\n");
  }
  else{
    printf("Flash mount error, error code:%d.\r\n",fr);
  }
  
  fr = f_mount(&PSRamFatFs, "/psram", 0);
  if(fr == FR_OK){
    printf("PSRAM mount ok!\r\n");
  }
  else{
    printf("PSRAM mount error, error code:%d.\r\n",fr);
  }
  
#if(0)  // Flash
  uint16_t write_num = 0;
  uint8_t write_dat[] = "This is STM32 working with FatFs using W25QXX as storage medium.\n";
  
  //---------S: First time ---------
  //W25QXX_Erase_Chip();
  
  MKFS_PARM mkfs_parm = { .fmt = FM_ANY, .n_fat = 2, .align = 1 };
  fr = f_mkfs("/flash", &mkfs_parm, NULL, 0));
  if (fr == FR_OK){
    printf("f_mkfs Ok!\r\n");
  }
  else{
    printf("f_mkfs Error, error code:%d.\r\n",fr);
  }
    
  fr = f_open(&FlashFile, "/flash/test.txt", FA_CREATE_ALWAYS | FA_WRITE);
  if(fr == FR_OK){
    printf("open file \"%s\" ok! \r\n", "test.txt");
  }
  else{
    printf("open file \"%s\" error : %d\r\n", "test.txt", fr);
  }
  
  fr = f_write(&FlashFile, write_dat, sizeof(write_dat), (void *)&write_num);
  if(fr == FR_OK){
    printf("write %d dat to file \"%s\" ok,dat is \"%s\".\r\n", write_num, "test.txt", write_dat);
  }
  else{
    printf("write dat to file \"%s\" error,error code is:%d\r\n", "test.txt", fr);
  }
  
  fr = f_close(&FlashFile);
  if(fr == FR_OK){
    printf("close file \"%s\" ok!\r\n", "test.txt");
  }
  else{
    printf("close file \"%s\" error, error code is:%d.\r\n", "test.txt", fr);
  }
  //---------E: First time ---------
#endif  
  
#if(1)  // PSRAM
  uint16_t write_num = 0;
  uint8_t write_dat[] = "This is STM32 working with FatFs using PSRAM as storage medium.\n";
  
  //---------S: First time ---------  
  MKFS_PARM mkfs_parm = { .fmt = FM_FAT, .n_fat = 2, .align = 1 };
  fr = f_mkfs("/psram", &mkfs_parm, NULL, 0);
  if (fr == FR_OK){
    printf("f_mkfs Ok!\r\n");
  }
  else{
    printf("f_mkfs Error, error code:%d.\r\n",fr);
  }
    
  fr = f_open(&PSRamFile, "/psram/test.txt", FA_CREATE_ALWAYS | FA_WRITE);
  if(fr == FR_OK){
    printf("open file \"%s\" ok! \r\n", "test.txt");
  }
  else{
    printf("open file \"%s\" error : %d\r\n", "test.txt", fr);
  }
  
  fr = f_write(&PSRamFile, write_dat, sizeof(write_dat), (void *)&write_num);
  if(fr == FR_OK){
    printf("write %d dat to file \"%s\" ok,dat is \"%s\".\r\n", write_num, "test.txt", write_dat);
  }
  else{
    printf("write dat to file \"%s\" error,error code is:%d\r\n", "test.txt", fr);
  }
  
  fr = f_close(&PSRamFile);
  if(fr == FR_OK){
    printf("close file \"%s\" ok!\r\n", "test.txt");
  }
  else{
    printf("close file \"%s\" error, error code is:%d.\r\n", "test.txt", fr);
  }
  //---------E: First time ---------
#endif    
  
#if(0)  // FLASH 
  uint16_t read_num = 0;
  uint8_t read_dat[100] = "";
  
  //---------S: General Use ---------
  fr = f_open(&FlashFile, "/flash/test.txt", FA_READ);
  if(fr == FR_OK){
    printf("open file \"%s\" ok! \r\n", "test.txt");
  }
  else{
    printf("open file \"%s\" error : %d\r\n", "test.txt", fr);
  }
  
  fr = f_read(&FlashFile, read_dat, sizeof(read_dat), (void *)&read_num);
  if(fr == FR_OK){
    printf("write %d dat to file \"%s\" ok,dat is \"%s\".\r\n", read_num, "test.txt", read_dat);
  }
  else{
    printf("write dat to file \"%s\" error,error code is:%d\r\n", "test.txt", fr);
  }
  
  fr = f_close(&FlashFile);
  if(fr == FR_OK){
    printf("close file \"%s\" ok!\r\n", "test.txt");
  }
  else{
    printf("close file \"%s\" error, error code is:%d.\r\n", "test.txt", fr);
  }
  //---------E: General Use ---------
#endif  
  
  
#if(1)  // PSRAM 
  uint16_t read_num = 0;
  uint8_t read_dat[100] = "";
  
  //---------S: General Use ---------
  fr = f_open(&PSRamFile, "/psram/test.txt", FA_READ);
  if(fr == FR_OK){
    printf("open file \"%s\" ok! \r\n", "test.txt");
  }
  else{
    printf("open file \"%s\" error : %d\r\n", "test.txt", fr);
  }
  
  fr = f_read(&PSRamFile, read_dat, sizeof(read_dat), (void *)&read_num);
  if(fr == FR_OK){
    printf("write %d dat to file \"%s\" ok,dat is \"%s\".\r\n", read_num, "test.txt", read_dat);
  }
  else{
    printf("write dat to file \"%s\" error,error code is:%d\r\n", "test.txt", fr);
  }
  
  fr = f_close(&PSRamFile);
  if(fr == FR_OK){
    printf("close file \"%s\" ok!\r\n", "test.txt");
  }
  else{
    printf("close file \"%s\" error, error code is:%d.\r\n", "test.txt", fr);
  }
  //---------E: General Use ---------
#endif
  
  
  
//  //-------- S: QSPI FW Flash Full Erase for first time boot --------
//  if(BSP_QSPI_Erase_Chip() == QSPI_OK){
//    FLASH_EXECUTE____FLAG = true;
//  }
//  else  {
//    Error_Handler();
//  }
//  //-------- E: QSPI FW Flash Full Erase for first time boot --------
  
  while (1)  {
    if(FLASH_EXECUTE____FLAG == true){
      FLASH_EXECUTE____FLAG = false;
      
      sMemMappedCfg.TimeOutActivation = QSPI_TIMEOUT_COUNTER_DISABLE;
      
      s_command.InstructionMode   	= QSPI_INSTRUCTION_1_LINE;
      s_command.Instruction       	= QUAD_INOUT_FAST_READ_CMD;
      s_command.AddressMode       	= QSPI_ADDRESS_4_LINES;
      s_command.Address           	= 0;
      s_command.AddressSize       	= QSPI_ADDRESS_24_BITS;
      s_command.AlternateByteMode 	= QSPI_ALTERNATE_BYTES_4_LINES;
      s_command.AlternateBytes 		= 0x00;
      s_command.AlternateBytesSize 	= QSPI_ALTERNATE_BYTES_8_BITS;
      s_command.DataMode          	= QSPI_DATA_4_LINES;
      s_command.DummyCycles       	= 4;
      s_command.NbData            	= 0;
      s_command.DdrMode           	= QSPI_DDR_MODE_DISABLE;
      s_command.DdrHoldHalfCycle  	= QSPI_DDR_HHC_ANALOG_DELAY;
      s_command.SIOOMode          	= QSPI_SIOO_INST_EVERY_CMD;
      //s_command.SIOOMode          = QSPI_SIOO_INST_ONLY_FIRST_CMD;
      
      
      if(HAL_QSPI_MemoryMapped(&hqspi, &s_command, &sMemMappedCfg) == HAL_OK){
        
        __disable_irq();
        
        // 1. Make sure, the CPU is in privileged mode.
        if( CONTROL_nPRIV_Msk & __get_CONTROL() ){  
          /* not in privileged mode */
          EnablePrivilegedMode();
        }
        
        // 2. Disable all enabled interrupts in NVIC.
        NVIC->ICER[0] = 0xFFFFFFFF;
        NVIC->ICER[1] = 0xFFFFFFFF;
        NVIC->ICER[2] = 0xFFFFFFFF;
        NVIC->ICER[3] = 0xFFFFFFFF;
        NVIC->ICER[4] = 0xFFFFFFFF;
        NVIC->ICER[5] = 0xFFFFFFFF;
        NVIC->ICER[6] = 0xFFFFFFFF;
        NVIC->ICER[7] = 0xFFFFFFFF;
        
        HAL_MspDeInit();
        
        SCB_DisableICache();
        SCB_DisableDCache(); SCB_CleanDCache();	
        
        HAL_RCC_DeInit();
        
        // 4. Clear all pending interrupt requests in NVIC.
        NVIC->ICPR[0] = 0xFFFFFFFF;
        NVIC->ICPR[1] = 0xFFFFFFFF;
        NVIC->ICPR[2] = 0xFFFFFFFF;
        NVIC->ICPR[3] = 0xFFFFFFFF;
        NVIC->ICPR[4] = 0xFFFFFFFF;
        NVIC->ICPR[5] = 0xFFFFFFFF;
        NVIC->ICPR[6] = 0xFFFFFFFF;
        NVIC->ICPR[7] = 0xFFFFFFFF;
        
        // 5. Disable SysTick and clear its exception pending bit, if it is used in the bootloader, e. g. by the RTX.
        SysTick->CTRL = 0;
        SCB->ICSR |= SCB_ICSR_PENDSTCLR_Msk;
        
        // 6. Disable individual fault handlers if the bootloader used them.
        SCB->SHCSR &= ~( SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_BUSFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk );
        
        // 7. Activate the MSP, if the core is found to currently run with the PSP.
        if( CONTROL_SPSEL_Msk & __get_CONTROL() ){
          /* MSP is not active */
          __set_CONTROL( __get_CONTROL() & ~CONTROL_SPSEL_Msk );
        }
        
        // 8. Load the vector table address of the user application into SCB->VTOR register. Make sure the address meets the alignment requirements.
        SCB->VTOR = QSPI_BASE;
        
        // 9. Set the MSP to the value found in the user application vector table.
        __set_MSP((*(__IO uint32_t*)QSPI_BASE));
        
        // 10. Set the PC to the reset vector value of the user application via a function call.
        JumpToApplication = (pFunction)(*(__IO uint32_t*)(QSPI_BASE+4));
        JumpToApplication();
      }
      else{
        
      }
    }
  }
}

void SystemClock_Config(void){
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
  
  /** Supply configuration update enable
  */
  HAL_PWREx_ConfigSupply(PWR_LDO_SUPPLY);
  
  /** Configure the main internal regulator output voltage
  */
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);
  
  while(!__HAL_PWR_GET_FLAG(PWR_FLAG_VOSRDY)) {}
  
  /** Initializes the RCC Oscillators according to the specified parameters
  * in the RCC_OscInitTypeDef structure.
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_ON;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 5;
  RCC_OscInitStruct.PLL.PLLN = 160;
  RCC_OscInitStruct.PLL.PLLP = 2;
  RCC_OscInitStruct.PLL.PLLQ = 10;
  RCC_OscInitStruct.PLL.PLLR = 2;
  RCC_OscInitStruct.PLL.PLLRGE = RCC_PLL1VCIRANGE_2;
  RCC_OscInitStruct.PLL.PLLVCOSEL = RCC_PLL1VCOWIDE;
  RCC_OscInitStruct.PLL.PLLFRACN = 0;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
  {
    Error_Handler();
  }
  
  /** Initializes the CPU, AHB and APB buses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
    |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2
      |RCC_CLOCKTYPE_D3PCLK1|RCC_CLOCKTYPE_D1PCLK1;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.SYSCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB3CLKDivider = RCC_APB3_DIV2;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_APB1_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_APB2_DIV2;
  RCC_ClkInitStruct.APB4CLKDivider = RCC_APB4_DIV2;
  
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_2) != HAL_OK)
  {
    Error_Handler();
  }
}

static void MX_QUADSPI_Init(void){
  
  HAL_QSPI_DeInit(&hqspi);
  
  /* ClockPrescaler:  		QPSI frequency division ratio, the maximum frequency of W25Q32 is 133MHz in 3.0V-3.6V, here 240/(1+1)=120MHz */
  /* FifoThreshold : 			FIFO depth is set to 32 bytes */
  /* SampleShifting : 		Configure QSPI to sample Flash drive data after half a CLK cycle after the Flash drive signal */
  /* FlashSize : 					22+1=23, 24-bit addressing, where 24-bit addressing is the byte search address (W25Q64 is 8M bytes) */
  /* ChipSelectHighTime : The chip select high level time is 8 clocks (12.5*8=100ns), which is the tSHSL parameter in the manual */
  
  hqspi.Instance = QUADSPI;
  hqspi.Init.ClockPrescaler = 2; 																
  hqspi.Init.FifoThreshold = 32; 																
  hqspi.Init.SampleShifting = QSPI_SAMPLE_SHIFTING_HALFCYCLE;  	
  hqspi.Init.FlashSize = 25; 																		
  hqspi.Init.ChipSelectHighTime = QSPI_CS_HIGH_TIME_8_CYCLE; 		
  hqspi.Init.ClockMode = QSPI_CLOCK_MODE_0;
  hqspi.Init.FlashID = QSPI_FLASH_ID_1;
  hqspi.Init.DualFlash = QSPI_DUALFLASH_DISABLE;
  if (HAL_QSPI_Init(&hqspi) != HAL_OK){
    Error_Handler();
  }
  
}

static void MX_SPI2_Init(void){
  
  hspi2.Instance = SPI2;
  hspi2.Init.Mode = SPI_MODE_MASTER;
  hspi2.Init.Direction = SPI_DIRECTION_2LINES;
  hspi2.Init.DataSize = SPI_DATASIZE_8BIT;
  hspi2.Init.CLKPolarity = SPI_POLARITY_LOW;
  hspi2.Init.CLKPhase = SPI_PHASE_1EDGE;
  hspi2.Init.NSS = SPI_NSS_SOFT;
  hspi2.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_2;
  hspi2.Init.FirstBit = SPI_FIRSTBIT_MSB;
  hspi2.Init.TIMode = SPI_TIMODE_DISABLE;
  hspi2.Init.CRCCalculation = SPI_CRCCALCULATION_DISABLE;
  hspi2.Init.CRCPolynomial = 0x0;
  hspi2.Init.NSSPMode = SPI_NSS_PULSE_ENABLE;
  hspi2.Init.NSSPolarity = SPI_NSS_POLARITY_LOW;
  hspi2.Init.FifoThreshold = SPI_FIFO_THRESHOLD_01DATA;
  hspi2.Init.TxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi2.Init.RxCRCInitializationPattern = SPI_CRC_INITIALIZATION_ALL_ZERO_PATTERN;
  hspi2.Init.MasterSSIdleness = SPI_MASTER_SS_IDLENESS_00CYCLE;
  hspi2.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
  hspi2.Init.MasterReceiverAutoSusp = SPI_MASTER_RX_AUTOSUSP_DISABLE;
  hspi2.Init.MasterKeepIOState = SPI_MASTER_KEEP_IO_STATE_ENABLE;
  hspi2.Init.IOSwap = SPI_IO_SWAP_DISABLE;
  if (HAL_SPI_Init(&hspi2) != HAL_OK)
  {
    Error_Handler();
  }
  
  MODIFY_REG(SPI2->CR2, SPI_CR2_TSIZE, 0);
  LL_SPI_Enable(SPI2);
}

static void MX_GPIO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};
  
  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOE_CLK_ENABLE();
  __HAL_RCC_GPIOH_CLK_ENABLE();
  __HAL_RCC_GPIOC_CLK_ENABLE();
  __HAL_RCC_GPIOB_CLK_ENABLE();
  __HAL_RCC_GPIOD_CLK_ENABLE();
  
  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOE, GPIO_PIN_4 | GPIO_PIN_6, GPIO_PIN_SET);
  
  /*Configure GPIO pin : SPI2_CS_Pin */
  GPIO_InitStruct.Pin = GPIO_PIN_4 | GPIO_PIN_6;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
  HAL_GPIO_Init(GPIOE, &GPIO_InitStruct);
}

void MPU_RegionConfig(void){
  MPU_Region_InitTypeDef MPU_InitStruct = {0};
  
  /* Disables the MPU */
  HAL_MPU_Disable();
  
  MPU_InitStruct.Enable                                 = MPU_REGION_ENABLE;
  MPU_InitStruct.Number                                 = MPU_REGION_NUMBER0;
  MPU_InitStruct.BaseAddress                            = 0x0;
  MPU_InitStruct.Size                                   = MPU_REGION_SIZE_4GB;
  MPU_InitStruct.SubRegionDisable                       = 0x87;
  MPU_InitStruct.TypeExtField                           = MPU_TEX_LEVEL0;
  MPU_InitStruct.AccessPermission                       = MPU_REGION_NO_ACCESS;
  MPU_InitStruct.IsShareable                            = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.IsCacheable                            = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsBufferable                           = MPU_ACCESS_NOT_BUFFERABLE;
  MPU_InitStruct.DisableExec                            = MPU_INSTRUCTION_ACCESS_DISABLE;
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  
  /* ITCMRAM 64KB */
  MPU_InitStruct.Enable 	  			= MPU_REGION_ENABLE;
  MPU_InitStruct.Number 	  			= MPU_REGION_NUMBER1;
  MPU_InitStruct.BaseAddress 	  	                = 0x00000000;
  MPU_InitStruct.Size 		  			= MPU_REGION_SIZE_64KB;
  MPU_InitStruct.SubRegionDisable                       = 0x0;
  MPU_InitStruct.TypeExtField 	                        = MPU_TEX_LEVEL1;
  MPU_InitStruct.AccessPermission                       = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsShareable 	  	                = MPU_ACCESS_NOT_SHAREABLE;
  MPU_InitStruct.IsCacheable 	  	                = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsBufferable 	                        = MPU_ACCESS_NOT_BUFFERABLE;
  MPU_InitStruct.DisableExec 	  	                = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  
  /* DTCMRAM 128KB */
  MPU_InitStruct.Enable 	  			= MPU_REGION_ENABLE;
  MPU_InitStruct.Number 	  			= MPU_REGION_NUMBER2;
  MPU_InitStruct.BaseAddress 	  	                = 0x20000000;
  MPU_InitStruct.Size 		  			= MPU_REGION_SIZE_128KB;
  MPU_InitStruct.SubRegionDisable                       = 0x0;
  MPU_InitStruct.TypeExtField 	                        = MPU_TEX_LEVEL1;
  MPU_InitStruct.AccessPermission                       = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsShareable 	  	                = MPU_ACCESS_NOT_SHAREABLE;
  MPU_InitStruct.IsCacheable 	  	                = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsBufferable 	                        = MPU_ACCESS_NOT_BUFFERABLE;
  MPU_InitStruct.DisableExec 	  	                = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion(&MPU_InitStruct);	
  
  /* AXISRAM 512KB */
  MPU_InitStruct.Enable 	  			= MPU_REGION_ENABLE;
  MPU_InitStruct.Number 	  			= MPU_REGION_NUMBER3;
  MPU_InitStruct.BaseAddress 	  	                = 0x24000000;
  MPU_InitStruct.Size 		  			= MPU_REGION_SIZE_512KB;
  MPU_InitStruct.SubRegionDisable                       = 0x0;
  MPU_InitStruct.TypeExtField 	                        = MPU_TEX_LEVEL1;
  MPU_InitStruct.AccessPermission                       = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsShareable 	  	                = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.IsCacheable 	  	                = MPU_ACCESS_CACHEABLE;
  MPU_InitStruct.IsBufferable 	                        = MPU_ACCESS_BUFFERABLE;
  MPU_InitStruct.DisableExec 	  	                = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  
  /* SRAM1 128KB*/
  MPU_InitStruct.Enable                                 = MPU_REGION_ENABLE;
  MPU_InitStruct.Number                                 = MPU_REGION_NUMBER4;
  MPU_InitStruct.BaseAddress                            = 0x30000000;
  MPU_InitStruct.Size                                   = MPU_REGION_SIZE_128KB;
  MPU_InitStruct.AccessPermission                       = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsBufferable                           = MPU_ACCESS_BUFFERABLE;
  MPU_InitStruct.IsCacheable                            = MPU_ACCESS_CACHEABLE;
  MPU_InitStruct.IsShareable                            = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.TypeExtField                           = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable                       = 0x00;
  MPU_InitStruct.DisableExec                            = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  
  /* SRAM2 128KB */
  MPU_InitStruct.Enable 	  			= MPU_REGION_ENABLE;
  MPU_InitStruct.Number 	  			= MPU_REGION_NUMBER5;
  MPU_InitStruct.BaseAddress 	  	                = 0x30020000;
  MPU_InitStruct.Size                                   = MPU_REGION_SIZE_128KB;
  MPU_InitStruct.AccessPermission                       = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsBufferable                           = MPU_ACCESS_BUFFERABLE;
  MPU_InitStruct.IsCacheable                            = MPU_ACCESS_CACHEABLE;
  MPU_InitStruct.IsShareable                            = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.TypeExtField                           = MPU_TEX_LEVEL1;
  MPU_InitStruct.SubRegionDisable                       = 0x00;
  MPU_InitStruct.DisableExec                            = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  
  /* SRAM3 : Ethernet  */
  MPU_InitStruct.Enable 	                        = MPU_REGION_ENABLE;
  MPU_InitStruct.Number 	                        = MPU_REGION_NUMBER6;
  MPU_InitStruct.BaseAddress 	                        = 0x30040000;
  MPU_InitStruct.Size 		                        = MPU_REGION_SIZE_32KB;
  MPU_InitStruct.AccessPermission                       = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsBufferable 	                        = MPU_ACCESS_BUFFERABLE;
  MPU_InitStruct.IsCacheable 	                        = MPU_ACCESS_NOT_CACHEABLE;
  MPU_InitStruct.IsShareable 	                        = MPU_ACCESS_NOT_SHAREABLE;
  MPU_InitStruct.TypeExtField 	                        = MPU_TEX_LEVEL0;
  MPU_InitStruct.SubRegionDisable                       = 0x00;
  MPU_InitStruct.DisableExec 	                        = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  
  /* SRAM4 64KB */
  MPU_InitStruct.Enable 	  			= MPU_REGION_ENABLE;
  MPU_InitStruct.Number 	  			= MPU_REGION_NUMBER7;
  MPU_InitStruct.BaseAddress 	  	                = 0x38000000;
  MPU_InitStruct.Size 		  			= MPU_REGION_SIZE_64KB;
  MPU_InitStruct.SubRegionDisable                       = 0x0;
  MPU_InitStruct.TypeExtField 	                        = MPU_TEX_LEVEL1;
  MPU_InitStruct.AccessPermission                       = MPU_REGION_FULL_ACCESS;
  MPU_InitStruct.IsShareable 	  	                = MPU_ACCESS_SHAREABLE;
  MPU_InitStruct.IsCacheable 	  	                = MPU_ACCESS_CACHEABLE;
  MPU_InitStruct.IsBufferable 	                        = MPU_ACCESS_BUFFERABLE;
  MPU_InitStruct.DisableExec 	  	                = MPU_INSTRUCTION_ACCESS_ENABLE;
  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  
//  /* Configure the MPU attributes as WT for QSPI (used 16Mbytes) */
//  MPU_InitStruct.Enable 				= MPU_REGION_ENABLE;
//  MPU_InitStruct.Number 				= MPU_REGION_NUMBER8;
//  MPU_InitStruct.BaseAddress 			        = 0x90000000;
//  MPU_InitStruct.Size 					= MPU_REGION_SIZE_16MB;
//  MPU_InitStruct.SubRegionDisable                       = 0x00;
//  MPU_InitStruct.TypeExtField 		                = MPU_TEX_LEVEL0;
//  MPU_InitStruct.AccessPermission                       = MPU_REGION_FULL_ACCESS;
//  MPU_InitStruct.IsShareable 			        = MPU_ACCESS_NOT_SHAREABLE;
//  MPU_InitStruct.IsCacheable 			        = MPU_ACCESS_CACHEABLE;
//  MPU_InitStruct.IsBufferable 		                = MPU_ACCESS_NOT_BUFFERABLE;
//  MPU_InitStruct.DisableExec 			        = MPU_INSTRUCTION_ACCESS_ENABLE;
//  HAL_MPU_ConfigRegion(&MPU_InitStruct);
  
  /* Enables the MPU */
  HAL_MPU_Enable(MPU_PRIVILEGED_DEFAULT);
}

void Error_Handler(void)
{
  /* USER CODE BEGIN Error_Handler_Debug */
  /* User can add his own implementation to report the HAL error return state */
  __disable_irq();
  while (1)
  {
  }
  /* USER CODE END Error_Handler_Debug */
}

#ifdef  USE_FULL_ASSERT
/**
* @brief  Reports the name of the source file and the source line number
*         where the assert_param error has occurred.
* @param  file: pointer to the source file name
* @param  line: assert_param error line source number
* @retval None
*/
void assert_failed(uint8_t *file, uint32_t line)
{
  /* USER CODE BEGIN 6 */
  /* User can add his own implementation to report the file name and line number,
  ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */
  /* USER CODE END 6 */
}
#endif /* USE_FULL_ASSERT */
